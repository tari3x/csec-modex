
channel c_in, c_out.

param N.

type nondet [fixed].

type fixed_20_nonce [fixed, large].

type bounded_40_host.
const hostA: bounded_40_host.
const hostB: bounded_40_host.

(************************
Public-key encryption
*************************)

(* IND-CCA2 probabilistic public-key encryption
keyseed: type of key seeds, must be "fixed" (to be able to generate random numbers from it), typically large.
pkey: type of public keys, must be "bounded"
skey: type of secret keys, must be "bounded"
cleartext: type of cleartexts, must be "bounded" or "fixed" (the encryptions of *all* cleartexts of any length
are assumed to be indistinguishable from each other).
ciphertext: type of ciphertexts
seed: type of random seeds for encryption, must be "fixed"

dk: public-key generation function
sk: secret-key generation function
E: encryption function
D: decryption function
injbot: natural injection from cleartext to bitstringbot
Z: a constant cleartext

Penc(t, N): probability of breaking the IND-CCA2 property
in time t for one key and N decryption queries.
Penccoll: probability of collision between independently generated keys
*)

type keyseed_T [fixed, large].
(* 100 is MAX_SIZE_KEY in the code. *)
type fixed_100_key [fixed].
type bounded_1000_ciphertext [bounded].
type bounded_200_cleartext [bounded].
type fixed_256_seed_T [fixed].

proba Penc.
proba Penccoll.

expand IND_CCA2_public_key_enc(keyseed_T, fixed_100_key, fixed_100_key, bounded_200_cleartext, bounded_1000_ciphertext, fixed_256_seed_T, dk, ek, E, D, injbot, Z, Penc, Penccoll).

fun inverse_injbot(bitstringbot): bounded_200_cleartext.

fun isek(fixed_100_key): fixed_100_key.

forall x: fixed_100_key;
isek(x) = x.

fun decrypt_len(bitstring): bitstring.
fun encrypt_len(bounded_200_cleartext): bitstring.
fun encrypt_lenZ(bounded_200_cleartext): bitstring.

fun Zbounded_200_cleartext(bounded_200_cleartext): bounded_200_cleartext.

(* Length of an encryption does not depend on the contents of the plaintext. *)
forall x: bounded_200_cleartext;
encrypt_len(x) = encrypt_lenZ(Zbounded_200_cleartext(x)).

(***************************
Signatures
***************************)

type spkey [bounded].
type sskey [bounded].
type skeyseed [large,fixed].
type sseed [fixed].
type signature [bounded].
type sblocksize [bounded].

proba Psign.
proba Psigncoll.

expand UF_CMA_signature(skeyseed, spkey, sskey, sblocksize, signature, sseed, sk, vk, sign, check, Psign, Psigncoll).

fun cert(fixed_100_key, bounded_40_host): sblocksize [compos].

fun check_key(bounded_40_host, fixed_100_key, signature, spkey): bool.

forall h: bounded_40_host, k: fixed_100_key, sig: signature, pkS: spkey;
check_key(h, k, sig, pkS) = check(cert(k, h), pkS, sig).


(*************************** 
  Formatting Functions 
***************************)

(* conc1 := "msg1"|(len(arg0))^[u,8]|arg0|arg1 *)
fun conc1(fixed_20_nonce, bounded_40_host): bounded_200_cleartext [compos].

(* conc2 := "encr"|(len(arg0))^[u,8]|arg0 *)
fun conc2(bounded_1000_ciphertext): bitstring [compos].

(* conc3 := "msg3"|arg0 *)
fun conc3(fixed_20_nonce): bounded_200_cleartext [compos].

(* conc4 := "encr"|(len(arg0))^[u,8]|arg0 *)
fun conc4(bounded_1000_ciphertext): bitstring [compos].

(* conc5 := "msg2"|(len(arg0))^[u,8]|(len(arg1))^[u,8]|arg0|arg1|arg2 *)
fun conc5(fixed_20_nonce, fixed_20_nonce, bounded_40_host): bounded_200_cleartext [compos].

(* conc6 := "encr"|(len(arg0))^[u,8]|arg0 *)
fun conc6(bounded_1000_ciphertext): bitstring [compos].

(* parse1 := arg0{20, 20} *)
fun parse1(bounded_200_cleartext): fixed_20_nonce.

(* parse2 := arg0{(arg0{4, 8})_[u,8] + (arg0{12, 8})_[u,8] + (2 * 8) + 4, len(arg0) - ((arg0{4, 8})_[u,8] + (arg0{12, 8})_[u,8] + (2 * 8) + 4)} *)
fun parse2(bounded_200_cleartext): bounded_40_host.

(* parse3 := arg0{20 + 20, ((arg0{4, 8})_[u,8] + (arg0{12, 8})_[u,8] + (2 * 8) + 4) - (20 + 20)} *)
fun parse3(bounded_200_cleartext): fixed_20_nonce.

(* parse4 := arg0{8 + (arg0{4, 8})_[u,8] + 4, len(arg0) - (8 + (arg0{4, 8})_[u,8] + 4)} *)
fun parse4(bounded_200_cleartext): bounded_40_host.

(* parse5 := arg0{12 + (arg0{4, 8})_[u,8], len(arg0) - (12 + (arg0{4, 8})_[u,8])} *)
fun parse5(bounded_200_cleartext): bounded_40_host.

(* parse6 := arg0{12, (arg0{4, 8})_[u,8]} *)
fun parse6(bounded_200_cleartext): fixed_20_nonce.

(* parse7 := arg0{4, len(arg0) - 4} *)
fun parse7(bounded_200_cleartext): fixed_20_nonce.


forall var1: bounded_1000_ciphertext;
  conc6(var1) = conc4(var1).
forall var1: bounded_1000_ciphertext;
  conc6(var1) = conc2(var1).
forall var1: fixed_20_nonce, var2: fixed_20_nonce, var3: bounded_40_host, var4: fixed_20_nonce;
  conc5(var1, var2, var3) <> conc3(var4).
forall var1: fixed_20_nonce, var2: fixed_20_nonce, var3: bounded_40_host, var4: fixed_20_nonce, var5: bounded_40_host;
  conc5(var1, var2, var3) <> conc1(var4, var5).
forall var1: bounded_1000_ciphertext;
  conc4(var1) = conc2(var1).
forall var1: fixed_20_nonce, var2: fixed_20_nonce, var3: bounded_40_host;
  conc3(var1) <> conc1(var2, var3).

(*************************** 
  Arithmetic Functions 
***************************)


(*************************** 
  Auxiliary Tests 
***************************)

(* auxiliary1 := len(arg0) = 112 *)
fun auxiliary1(bitstring): bool.

(* auxiliary10 := ¬(len(arg0) > 100) *)
fun auxiliary10(fixed_100_key): bool.

(* auxiliary11 := len(arg0) = ((4)^[u,8] - (0)^[u,8])_[u,8] *)
fun auxiliary11(bitstring): bool.

(* auxiliary12 := len(arg0) = ((8)^[u,8] - (0)^[u,8])_[u,8] *)
fun auxiliary12(bitstring): bool.

(* auxiliary13 := ¬((arg0)_[u,8] > 1000) *)
fun auxiliary13(bitstring): bool.

(* auxiliary14 := 0 < (arg0)_[u,8] *)
fun auxiliary14(bitstring): bool.

(* auxiliary15 := len(arg0) = (arg1 - (0)^[u,8])_[u,8] *)
fun auxiliary15(bitstring, bitstring): bool.

(* auxiliary16 := Defined(decrypt_len(arg0)) *)
fun auxiliary16(bitstring): bool.

(* auxiliary17 := ¬((decrypt_len(arg0))_[u,8] > (arg1)_[u,8]) *)
fun auxiliary17(bitstring, bitstring): bool.

(* auxiliary18 := ¬(len(arg0) > (decrypt_len(arg1))_[u,8]) *)
fun auxiliary18(bounded_200_cleartext, bitstring): bool.

(* auxiliary19 := ¬((8 + 20 + 4) >= len(arg0)) *)
fun auxiliary19(bounded_200_cleartext): bool.

(* auxiliary2 := len(arg0) = 8 *)
fun auxiliary2(bitstring): bool.

(* auxiliary20 := arg0{0, 4} = "msg1" *)
fun auxiliary20(bounded_200_cleartext): bool.

(* auxiliary21 := ¬((arg0{4, 8})_[u,8] <> 20) *)
fun auxiliary21(bounded_200_cleartext): bool.

(* auxiliary22 := ¬((len(arg0) - (8 + (arg0{4, 8})_[u,8] + 4)) > 40) *)
fun auxiliary22(bounded_200_cleartext): bool.

(* auxiliary23 := ¬(len(arg0) > 100) *)
fun auxiliary23(fixed_100_key): bool.

(* auxiliary24 := ¬((arg0)_[u,8] > 1000) *)
fun auxiliary24(bitstring): bool.

(* auxiliary25 := ¬(len(arg0) > (arg1)_[u,8]) *)
fun auxiliary25(bounded_1000_ciphertext, bitstring): bool.

(* auxiliary26 := len(arg0) = ((4)^[u,8] - (0)^[u,8])_[u,8] *)
fun auxiliary26(bitstring): bool.

(* auxiliary27 := len(arg0) = ((8)^[u,8] - (0)^[u,8])_[u,8] *)
fun auxiliary27(bitstring): bool.

(* auxiliary28 := ¬((arg0)_[u,8] > 1000) *)
fun auxiliary28(bitstring): bool.

(* auxiliary29 := 0 < (arg0)_[u,8] *)
fun auxiliary29(bitstring): bool.

(* auxiliary3 := ¬((arg0)_[s,8] <= 0) *)
fun auxiliary3(bitstring): bool.

(* auxiliary30 := len(arg0) = (arg1 - (0)^[u,8])_[u,8] *)
fun auxiliary30(bitstring, bitstring): bool.

(* auxiliary31 := Defined(decrypt_len(arg0)) *)
fun auxiliary31(bitstring): bool.

(* auxiliary32 := ¬((decrypt_len(arg0))_[u,8] > (arg1)_[u,8]) *)
fun auxiliary32(bitstring, bitstring): bool.

(* auxiliary33 := ¬(len(arg0) > (decrypt_len(arg1))_[u,8]) *)
fun auxiliary33(bounded_200_cleartext, bitstring): bool.

(* auxiliary34 := arg0{0, 4} = "msg3" *)
fun auxiliary34(bounded_200_cleartext): bool.

(* auxiliary35 := ¬(len(arg0) <> 24) *)
fun auxiliary35(bounded_200_cleartext): bool.

(* auxiliary36 := len(arg0) = 112 *)
fun auxiliary36(bitstring): bool.

(* auxiliary37 := len(arg0) = 8 *)
fun auxiliary37(bitstring): bool.

(* auxiliary38 := ¬((arg0)_[s,8] <= 0) *)
fun auxiliary38(bitstring): bool.

(* auxiliary39 := ¬(len(arg0) > 40) *)
fun auxiliary39(bounded_40_host): bool.

(* auxiliary4 := len(arg0) = 8 *)
fun auxiliary4(bitstring): bool.

(* auxiliary40 := ¬(len(arg0) > 40) *)
fun auxiliary40(bounded_40_host): bool.

(* auxiliary41 := ¬(len(arg0) > 100) *)
fun auxiliary41(fixed_100_key): bool.

(* auxiliary42 := ¬(len(arg0) > 100) *)
fun auxiliary42(fixed_100_key): bool.

(* auxiliary43 := ¬(len(arg0) > 100) *)
fun auxiliary43(fixed_100_key): bool.

(* auxiliary44 := ¬((arg0)_[u,8] > 1000) *)
fun auxiliary44(bitstring): bool.

(* auxiliary45 := ¬(len(arg0) > (arg1)_[u,8]) *)
fun auxiliary45(bounded_1000_ciphertext, bitstring): bool.

(* auxiliary46 := len(arg0) = ((4)^[u,8] - (0)^[u,8])_[u,8] *)
fun auxiliary46(bitstring): bool.

(* auxiliary47 := len(arg0) = ((8)^[u,8] - (0)^[u,8])_[u,8] *)
fun auxiliary47(bitstring): bool.

(* auxiliary48 := ¬((arg0)_[u,8] > 1000) *)
fun auxiliary48(bitstring): bool.

(* auxiliary49 := 0 < (arg0)_[u,8] *)
fun auxiliary49(bitstring): bool.

(* auxiliary5 := ¬((arg0)_[s,8] <= 0) *)
fun auxiliary5(bitstring): bool.

(* auxiliary50 := len(arg0) = (arg1 - (0)^[u,8])_[u,8] *)
fun auxiliary50(bitstring, bitstring): bool.

(* auxiliary51 := Defined(decrypt_len(arg0)) *)
fun auxiliary51(bitstring): bool.

(* auxiliary52 := ¬((decrypt_len(arg0))_[u,8] > (arg1)_[u,8]) *)
fun auxiliary52(bitstring, bitstring): bool.

(* auxiliary53 := ¬(len(arg0) > (decrypt_len(arg1))_[u,8]) *)
fun auxiliary53(bounded_200_cleartext, bitstring): bool.

(* auxiliary54 := ¬((len(arg0) + 40 + (2 * 8) + 4) <> len(arg1)) *)
fun auxiliary54(bounded_40_host, bounded_200_cleartext): bool.

(* auxiliary55 := arg0{0, 4} = "msg2" *)
fun auxiliary55(bounded_200_cleartext): bool.

(* auxiliary56 := ¬((arg0{4, 8})_[u,8] <> 20) *)
fun auxiliary56(bounded_200_cleartext): bool.

(* auxiliary57 := ¬((arg0{12, 8})_[u,8] <> 20) *)
fun auxiliary57(bounded_200_cleartext): bool.

(* auxiliary58 := ¬((arg0)_[u,8] > 1000) *)
fun auxiliary58(bitstring): bool.

(* auxiliary59 := ¬(len(arg0) > (arg1)_[u,8]) *)
fun auxiliary59(bounded_1000_ciphertext, bitstring): bool.

(* auxiliary6 := len(arg0) = 112 *)
fun auxiliary6(bitstring): bool.

(* auxiliary7 := len(arg0) = 4 *)
fun auxiliary7(bitstring): bool.

(* auxiliary8 := ¬(len(arg0) > 40) *)
fun auxiliary8(bounded_40_host): bool.

(* auxiliary9 := ¬(len(arg0) > 100) *)
fun auxiliary9(fixed_100_key): bool.


(*************************** 
  Zero Functions 
***************************)

fun Zbitstring(bitstring): bitstring.

fun Zbitstring_prime(bitstring): bitstring.

fun Zbounded_1000_ciphertext(bounded_1000_ciphertext): bounded_1000_ciphertext.

fun Zbounded_1000_ciphertext_prime(bounded_1000_ciphertext): bounded_1000_ciphertext.

(* Zbounded_200_cleartext is already defined in the template *)

fun Zbounded_200_cleartext_prime(bounded_200_cleartext): bounded_200_cleartext.

fun Zbounded_40_host(bounded_40_host): bounded_40_host.

fun Zbounded_40_host_prime(bounded_40_host): bounded_40_host.

fun Zfixed_100_key(fixed_100_key): fixed_100_key.

fun Zfixed_100_key_prime(fixed_100_key): fixed_100_key.

fun Zfixed_20_nonce(fixed_20_nonce): fixed_20_nonce.

fun Zfixed_20_nonce_prime(fixed_20_nonce): fixed_20_nonce.

fun Zfixed_256_seed_T(fixed_256_seed_T): fixed_256_seed_T.

fun Zfixed_256_seed_T_prime(fixed_256_seed_T): fixed_256_seed_T.

const zero_fixed_100_key: fixed_100_key.

const zero_fixed_20_nonce: fixed_20_nonce.

const zero_fixed_256_seed_T: fixed_256_seed_T.


(*************************** 
  Primed Functions 
***************************)

fun auxiliary9_prime(fixed_100_key): bool.

fun auxiliary8_prime(bounded_40_host): bool.

fun auxiliary7_prime(bitstring): bool.

fun auxiliary6_prime(bitstring): bool.

fun auxiliary59_prime(bounded_1000_ciphertext, bitstring): bool.

fun auxiliary54_prime(bounded_40_host, bounded_200_cleartext): bool.

fun auxiliary53_prime(bounded_200_cleartext, bitstring): bool.

fun auxiliary50_prime(bitstring, bitstring): bool.

fun auxiliary47_prime(bitstring): bool.

fun auxiliary46_prime(bitstring): bool.

fun auxiliary45_prime(bounded_1000_ciphertext, bitstring): bool.

fun auxiliary43_prime(fixed_100_key): bool.

fun auxiliary42_prime(fixed_100_key): bool.

fun auxiliary41_prime(fixed_100_key): bool.

fun auxiliary40_prime(bounded_40_host): bool.

fun auxiliary4_prime(bitstring): bool.

fun auxiliary39_prime(bounded_40_host): bool.

fun auxiliary37_prime(bitstring): bool.

fun auxiliary36_prime(bitstring): bool.

fun auxiliary35_prime(bounded_200_cleartext): bool.

fun auxiliary33_prime(bounded_200_cleartext, bitstring): bool.

fun auxiliary30_prime(bitstring, bitstring): bool.

fun auxiliary27_prime(bitstring): bool.

fun auxiliary26_prime(bitstring): bool.

fun auxiliary25_prime(bounded_1000_ciphertext, bitstring): bool.

fun auxiliary23_prime(fixed_100_key): bool.

fun conc5_prime(fixed_20_nonce, fixed_20_nonce, bounded_40_host): bounded_200_cleartext.

fun conc3_prime(fixed_20_nonce): bounded_200_cleartext.

fun conc1_prime(fixed_20_nonce, bounded_40_host): bounded_200_cleartext.

fun auxiliary2_prime(bitstring): bool.

fun auxiliary19_prime(bounded_200_cleartext): bool.

fun auxiliary18_prime(bounded_200_cleartext, bitstring): bool.

fun auxiliary15_prime(bitstring, bitstring): bool.

fun auxiliary12_prime(bitstring): bool.

fun auxiliary11_prime(bitstring): bool.

fun auxiliary10_prime(fixed_100_key): bool.

fun auxiliary1_prime(bitstring): bool.


(*************************** 
  Typecasting 
***************************)

fun cast_bitstring_bounded_1000_ciphertext(bitstring): bounded_1000_ciphertext [compos].

(*************************** 
  Auxiliary Facts 
***************************)

forall arg0: fixed_100_key;
	auxiliary9(arg0) = auxiliary9_prime(Zfixed_100_key(arg0)).
forall arg0: bounded_40_host;
	auxiliary8(arg0) = auxiliary8_prime(Zbounded_40_host(arg0)).
forall arg0: bitstring;
	auxiliary7(arg0) = auxiliary7_prime(Zbitstring(arg0)).
forall arg0: bitstring;
	auxiliary6(arg0) = auxiliary6_prime(Zbitstring(arg0)).
forall arg1: bitstring, arg0: bounded_1000_ciphertext;
	auxiliary59(arg0, arg1) = auxiliary59_prime(Zbounded_1000_ciphertext(arg0), arg1).
forall x25: bounded_40_host, x24: fixed_20_nonce, x23: fixed_20_nonce;
	auxiliary57(conc5(x23, x24, x25)) = auxiliary57(conc5_prime(Zfixed_20_nonce(x23), Zfixed_20_nonce(x24), Zbounded_40_host(x25))).
forall x33: bounded_40_host, x32: fixed_20_nonce, x31: fixed_20_nonce;
	auxiliary56(conc5(x31, x32, x33)) = auxiliary56(conc5_prime(Zfixed_20_nonce(x31), Zfixed_20_nonce(x32), Zbounded_40_host(x33))).
forall x36: bounded_40_host, x35: fixed_20_nonce;
	auxiliary56(conc1(x35, x36)) = auxiliary56(conc1_prime(Zfixed_20_nonce(x35), Zbounded_40_host(x36))).
forall x41: bounded_40_host, x40: fixed_20_nonce, x39: fixed_20_nonce;
	auxiliary55(conc5(x39, x40, x41)) = auxiliary55(conc5_prime(Zfixed_20_nonce(x39), Zfixed_20_nonce(x40), Zbounded_40_host(x41))).
forall x42: fixed_20_nonce;
	auxiliary55(conc3(x42)) = auxiliary55(conc3_prime(Zfixed_20_nonce(x42))).
forall x44: bounded_40_host, x43: fixed_20_nonce;
	auxiliary55(conc1(x43, x44)) = auxiliary55(conc1_prime(Zfixed_20_nonce(x43), Zbounded_40_host(x44))).
forall arg1: bounded_200_cleartext, arg0: bounded_40_host;
	auxiliary54(arg0, arg1) = auxiliary54_prime(Zbounded_40_host(arg0), Zbounded_200_cleartext(arg1)).
forall arg1: bitstring, arg0: bounded_200_cleartext;
	auxiliary53(arg0, arg1) = auxiliary53_prime(Zbounded_200_cleartext(arg0), arg1).
forall arg1: bitstring, arg0: bitstring;
	auxiliary50(arg0, arg1) = auxiliary50_prime(Zbitstring(arg0), arg1).
forall arg0: bitstring;
	auxiliary47(arg0) = auxiliary47_prime(Zbitstring(arg0)).
forall arg0: bitstring;
	auxiliary46(arg0) = auxiliary46_prime(Zbitstring(arg0)).
forall arg1: bitstring, arg0: bounded_1000_ciphertext;
	auxiliary45(arg0, arg1) = auxiliary45_prime(Zbounded_1000_ciphertext(arg0), arg1).
forall arg0: fixed_100_key;
	auxiliary43(arg0) = auxiliary43_prime(Zfixed_100_key(arg0)).
forall arg0: fixed_100_key;
	auxiliary42(arg0) = auxiliary42_prime(Zfixed_100_key(arg0)).
forall arg0: fixed_100_key;
	auxiliary41(arg0) = auxiliary41_prime(Zfixed_100_key(arg0)).
forall arg0: bounded_40_host;
	auxiliary40(arg0) = auxiliary40_prime(Zbounded_40_host(arg0)).
forall arg0: bitstring;
	auxiliary4(arg0) = auxiliary4_prime(Zbitstring(arg0)).
forall arg0: bounded_40_host;
	auxiliary39(arg0) = auxiliary39_prime(Zbounded_40_host(arg0)).
forall arg0: bitstring;
	auxiliary37(arg0) = auxiliary37_prime(Zbitstring(arg0)).
forall arg0: bitstring;
	auxiliary36(arg0) = auxiliary36_prime(Zbitstring(arg0)).
forall arg0: bounded_200_cleartext;
	auxiliary35(arg0) = auxiliary35_prime(Zbounded_200_cleartext(arg0)).
forall x136: bounded_40_host, x135: fixed_20_nonce, x134: fixed_20_nonce;
	auxiliary34(conc5(x134, x135, x136)) = auxiliary34(conc5_prime(Zfixed_20_nonce(x134), Zfixed_20_nonce(x135), Zbounded_40_host(x136))).
forall x137: fixed_20_nonce;
	auxiliary34(conc3(x137)) = auxiliary34(conc3_prime(Zfixed_20_nonce(x137))).
forall x139: bounded_40_host, x138: fixed_20_nonce;
	auxiliary34(conc1(x138, x139)) = auxiliary34(conc1_prime(Zfixed_20_nonce(x138), Zbounded_40_host(x139))).
forall arg1: bitstring, arg0: bounded_200_cleartext;
	auxiliary33(arg0, arg1) = auxiliary33_prime(Zbounded_200_cleartext(arg0), arg1).
forall arg1: bitstring, arg0: bitstring;
	auxiliary30(arg0, arg1) = auxiliary30_prime(Zbitstring(arg0), arg1).
forall arg0: bitstring;
	auxiliary27(arg0) = auxiliary27_prime(Zbitstring(arg0)).
forall arg0: bitstring;
	auxiliary26(arg0) = auxiliary26_prime(Zbitstring(arg0)).
forall arg1: bitstring, arg0: bounded_1000_ciphertext;
	auxiliary25(arg0, arg1) = auxiliary25_prime(Zbounded_1000_ciphertext(arg0), arg1).
forall arg0: fixed_100_key;
	auxiliary23(arg0) = auxiliary23_prime(Zfixed_100_key(arg0)).
forall x206: bounded_40_host, x205: fixed_20_nonce, x204: fixed_20_nonce;
	auxiliary22(conc5(x204, x205, x206)) = auxiliary22(conc5_prime(Zfixed_20_nonce(x204), Zfixed_20_nonce(x205), Zbounded_40_host(x206))).
forall x209: bounded_40_host, x208: fixed_20_nonce;
	auxiliary22(conc1(x208, x209)) = auxiliary22(conc1_prime(Zfixed_20_nonce(x208), Zbounded_40_host(x209))).
forall x214: bounded_40_host, x213: fixed_20_nonce, x212: fixed_20_nonce;
	auxiliary21(conc5(x212, x213, x214)) = auxiliary21(conc5_prime(Zfixed_20_nonce(x212), Zfixed_20_nonce(x213), Zbounded_40_host(x214))).
forall x217: bounded_40_host, x216: fixed_20_nonce;
	auxiliary21(conc1(x216, x217)) = auxiliary21(conc1_prime(Zfixed_20_nonce(x216), Zbounded_40_host(x217))).
forall x222: bounded_40_host, x221: fixed_20_nonce, x220: fixed_20_nonce;
	auxiliary20(conc5(x220, x221, x222)) = auxiliary20(conc5_prime(Zfixed_20_nonce(x220), Zfixed_20_nonce(x221), Zbounded_40_host(x222))).
forall x223: fixed_20_nonce;
	auxiliary20(conc3(x223)) = auxiliary20(conc3_prime(Zfixed_20_nonce(x223))).
forall x225: bounded_40_host, x224: fixed_20_nonce;
	auxiliary20(conc1(x224, x225)) = auxiliary20(conc1_prime(Zfixed_20_nonce(x224), Zbounded_40_host(x225))).
forall arg0: bitstring;
	auxiliary2(arg0) = auxiliary2_prime(Zbitstring(arg0)).
forall arg0: bounded_200_cleartext;
	auxiliary19(arg0) = auxiliary19_prime(Zbounded_200_cleartext(arg0)).
forall arg1: bitstring, arg0: bounded_200_cleartext;
	auxiliary18(arg0, arg1) = auxiliary18_prime(Zbounded_200_cleartext(arg0), arg1).
forall arg1: bitstring, arg0: bitstring;
	auxiliary15(arg0, arg1) = auxiliary15_prime(Zbitstring(arg0), arg1).
forall arg0: bitstring;
	auxiliary12(arg0) = auxiliary12_prime(Zbitstring(arg0)).
forall arg0: bitstring;
	auxiliary11(arg0) = auxiliary11_prime(Zbitstring(arg0)).
forall arg0: fixed_100_key;
	auxiliary10(arg0) = auxiliary10_prime(Zfixed_100_key(arg0)).
forall arg0: bitstring;
	auxiliary1(arg0) = auxiliary1_prime(Zbitstring(arg0)).

(*************************** 
  Zero Facts 
***************************)

forall arg0: bounded_1000_ciphertext;
	Zbitstring(conc6(arg0)) = Zbitstring_prime(conc6(Zbounded_1000_ciphertext(arg0))).
forall arg2: bounded_40_host, arg1: fixed_20_nonce, arg0: fixed_20_nonce;
	Zbounded_200_cleartext(conc5(arg0, arg1, arg2)) = Zbounded_200_cleartext_prime(conc5(Zfixed_20_nonce(arg0), Zfixed_20_nonce(arg1), Zbounded_40_host(arg2))).
forall arg0: bounded_1000_ciphertext;
	Zbitstring(conc4(arg0)) = Zbitstring_prime(conc4(Zbounded_1000_ciphertext(arg0))).
forall arg0: fixed_20_nonce;
	Zbounded_200_cleartext(conc3(arg0)) = Zbounded_200_cleartext_prime(conc3(Zfixed_20_nonce(arg0))).
forall arg0: bounded_1000_ciphertext;
	Zbitstring(conc2(arg0)) = Zbitstring_prime(conc2(Zbounded_1000_ciphertext(arg0))).
forall arg1: bounded_40_host, arg0: fixed_20_nonce;
	Zbounded_200_cleartext(conc1(arg0, arg1)) = Zbounded_200_cleartext_prime(conc1(Zfixed_20_nonce(arg0), Zbounded_40_host(arg1))).
forall x: bitstring;
	Zbounded_1000_ciphertext(cast_bitstring_bounded_1000_ciphertext(x)) = Zbounded_1000_ciphertext_prime(cast_bitstring_bounded_1000_ciphertext(Zbitstring(x))).
forall x: fixed_20_nonce;
	Zfixed_20_nonce(x) = zero_fixed_20_nonce().
forall x: fixed_256_seed_T;
	Zfixed_256_seed_T(x) = zero_fixed_256_seed_T().
forall x: fixed_100_key;
	Zfixed_100_key(x) = zero_fixed_100_key().

(********************
<Query>
********************)

event beginA(bounded_40_host, bounded_40_host).
event beginB(bounded_40_host, bounded_40_host).
event endA(bounded_40_host, bounded_40_host).
event endB(bounded_40_host, bounded_40_host).
event bad(bounded_40_host).

(* na: nonce, nb: nonce *)
query x: bounded_40_host, y: bounded_40_host;
event endB(x, y) ==> beginA(x, y) || bad(x).

query x: bounded_40_host, y: bounded_40_host;
event endA(x, y) ==> beginB(x, y) || bad(y).


(*************************** 
  Model 
***************************)

let client = 
in(c_in, (var1: bitstring, BIO_ctrl_result1: bitstring));
if auxiliary36(var1) then 
if auxiliary37(BIO_ctrl_result1) then 
if auxiliary38(BIO_ctrl_result1) then 
new nondet1: nondet;
new nondet2: nondet;
new nondet3: nondet;
new nondet4: nondet;
new nondet5: nondet;
new nondet6: nondet;
if check_key(hostX, pkX, sigX, pkS) then 
new nondet7: nondet;
new nondet8: nondet;
event beginA(hostA, hostX);
new nonce1: fixed_20_nonce;
let msg1 = conc1(nonce1, hostA) in
let len2 = encrypt_len(msg1) in
if auxiliary44(len2) then 
let key3 = isek(pkX) in
new nonce2: fixed_256_seed_T;
let cipher1 = E(msg1, key3, nonce2) in
if auxiliary45(cipher1, len2) then 
let msg2 = conc2(cipher1) in
new nondet9: nondet;
new nondet10: nondet;
out(c_out, msg2);
in(c_in, (var5: bitstring, msg4: bitstring, cipher2: bitstring));
if auxiliary46(var5) then 
if auxiliary47(msg4) then 
if auxiliary48(msg4) then 
if auxiliary49(msg4) then 
if auxiliary50(cipher2, msg4) then 
if auxiliary51(cipher2) then 
if auxiliary52(cipher2, msg4) then 
let msg6 = D(cast_bitstring_bounded_1000_ciphertext(cipher2), skA) in
let injbot(msg7) = msg6 in
if auxiliary53(msg7, cipher2) then 
if auxiliary54(hostX, msg7) then 
if auxiliary55(msg7) then 
if auxiliary56(msg7) then 
if auxiliary57(msg7) then 
let conc5(var61, var65, var63) = msg7 in
let var62 = var61 in
if var62 = nonce1 then 
let var64 = var63 in
if var64 = hostX then 
new nondet11: nondet;
new nondet12: nondet;
let var66 = var65 in
let msg8 = conc3(var66) in
let len4 = encrypt_len(msg8) in
if auxiliary58(len4) then 
new nonce3: fixed_256_seed_T;
let cipher3 = E(msg8, key3, nonce3) in
if auxiliary59(cipher3, len4) then 
let msg9 = conc4(cipher3) in
new nondet13: nondet;
new nondet14: nondet;
new nondet15: nondet;
new nondet16: nondet;
new nondet17: nondet;
new nondet18: nondet;
event endA(hostA, hostX);
out(c_out, msg9); 0 .

let server = 
in(c_in, (var9: bitstring, BIO_ctrl_result2: bitstring, BIO_ctrl_result3: bitstring, var12: bitstring, var13: bitstring, var14: bitstring, msg11: bitstring, cipher4: bitstring));
if auxiliary1(var9) then 
if auxiliary2(BIO_ctrl_result2) then 
if auxiliary3(BIO_ctrl_result2) then 
if auxiliary4(BIO_ctrl_result3) then 
if auxiliary5(BIO_ctrl_result3) then 
if auxiliary6(var12) then 
if auxiliary7(var13) then 
new nondet19: nondet;
new nondet20: nondet;
new nondet21: nondet;
new nondet22: nondet;
if auxiliary11(var14) then 
if auxiliary12(msg11) then 
if auxiliary13(msg11) then 
if auxiliary14(msg11) then 
if auxiliary15(cipher4, msg11) then 
if auxiliary16(cipher4) then 
if auxiliary17(cipher4, msg11) then 
let msg13 = D(cast_bitstring_bounded_1000_ciphertext(cipher4), skB) in
let injbot(msg14) = msg13 in
if auxiliary18(msg14, cipher4) then 
if auxiliary19(msg14) then 
if auxiliary20(msg14) then 
if auxiliary21(msg14) then 
if auxiliary22(msg14) then 
new nondet23: nondet;
new nondet24: nondet;
let conc1(var28, host2) = msg14 in
if check_key(host2, pkX, sigX, pkS) then 
new nondet25: nondet;
new nondet26: nondet;
new nondet27: nondet;
new nondet28: nondet;
event beginB(host2, hostB);
new nonce4: fixed_20_nonce;
let var29 = var28 in
let msg15 = conc5(var29, nonce4, hostB) in
let len6 = encrypt_len(msg15) in
if auxiliary24(len6) then 
let key10 = isek(pkX) in
new nonce5: fixed_256_seed_T;
let cipher5 = E(msg15, key10, nonce5) in
if auxiliary25(cipher5, len6) then 
let msg16 = conc6(cipher5) in
new nondet29: nondet;
new nondet30: nondet;
out(c_out, msg16);
in(c_in, (var19: bitstring, msg18: bitstring, cipher6: bitstring));
if auxiliary26(var19) then 
if auxiliary27(msg18) then 
if auxiliary28(msg18) then 
if auxiliary29(msg18) then 
if auxiliary30(cipher6, msg18) then 
if auxiliary31(cipher6) then 
if auxiliary32(cipher6, msg18) then 
let msg20 = D(cast_bitstring_bounded_1000_ciphertext(cipher6), skB) in
let injbot(msg21) = msg20 in
if auxiliary33(msg21, cipher6) then 
if auxiliary34(msg21) then 
if auxiliary35(msg21) then 
let conc3(var48) = msg21 in
let var49 = var48 in
if var49 = nonce4 then 
new nondet31: nondet;
new nondet32: nondet;
new nondet33: nondet;
new nondet34: nondet;
event endB(host2, hostB);
yield .

(***************************
<Environment>
***************************)

let client' =
in(c_in, (pkX: fixed_100_key, hostX: bounded_40_host, sigX: signature));
out(c_out, ());
client .

let server' =
in(c_in, (pkX: fixed_100_key, sigX: signature));
out(c_out, ());
server .

let keyServer =
in(c_in, (h: bounded_40_host, k: fixed_100_key));
let rk =
if h = hostA then pkA else
if h = hostB then pkB else
k in
new r3: sseed;
let cert = (rk, h, sign(cert(rk, h), skS, r3)) in
if h = hostA || h = hostB then
out(c_out, cert)
else
event bad(h);
out(c_out, cert) .

process
! N (
in(c_in, ());
new A_seed: keyseed_T;
new B_seed: keyseed_T;
let pkA = ek(A_seed) in
let skA = dk(A_seed) in
let pkB = ek(B_seed) in
let skB = dk(B_seed) in

new rkS: skeyseed;
let pkS = vk(rkS) in
let skS = sk(rkS) in

out(c_out, (pkA, pkB, pkS));
((! N client') | (! N server') | (! N keyServer))
)



channel c_in, c_out. 

param N.

type nondet [fixed].

type fixed_20_nonce [fixed, large].

type bounded_40_host.
const hostA: bounded_40_host.
const hostB: bounded_40_host.

(************************
  Public-key encryption
*************************)

(* IND-CCA2 probabilistic public-key encryption 
   keyseed: type of key seeds, must be "fixed" (to be able to generate random numbers from it), typically large.
   pkey: type of public keys, must be "bounded"
   skey: type of secret keys, must be "bounded"
   cleartext: type of cleartexts, must be "bounded" or "fixed" (the encryptions of *all* cleartexts of any length
              are assumed to be indistinguishable from each other).
   ciphertext: type of ciphertexts
   seed: type of random seeds for encryption, must be "fixed"

   dk: public-key generation function 
   sk: secret-key generation function
   E: encryption function
   D: decryption function
   injbot: natural injection from cleartext to bitstringbot
   Z: a constant cleartext

   Penc(t, N): probability of breaking the IND-CCA2 property
   in time t for one key and N decryption queries.
   Penccoll: probability of collision between independently generated keys
*)

type keyseed_T [fixed, large].
(* 100 is MAX_SIZE_KEY in the code. *)
type fixed_100_key [fixed].
type bounded_1000_ciphertext [bounded].
type bounded_200_cleartext [bounded].
type fixed_256_seed_T [fixed].

proba Penc.
proba Penccoll.

expand IND_CCA2_public_key_enc(keyseed_T, fixed_100_key, fixed_100_key, bounded_200_cleartext, bounded_1000_ciphertext, fixed_256_seed_T, dk, ek, E, D, injbot, Z, Penc, Penccoll).

fun inverse_injbot(bitstringbot): bounded_200_cleartext.

fun isek(fixed_100_key): fixed_100_key.

forall x: fixed_100_key;
  isek(x) = x.

fun decrypt_len(bitstring): bitstring.
fun encrypt_len(bounded_200_cleartext): bitstring.
fun encrypt_lenZ(bounded_200_cleartext): bitstring.
  
fun Zbounded_200_cleartext(bounded_200_cleartext): bounded_200_cleartext.

(* Length of an encryption does not depend on the contents of the plaintext. *)
forall x: bounded_200_cleartext;
  encrypt_len(x) = encrypt_lenZ(Zbounded_200_cleartext(x)).

(*************************** 
 Signatures
***************************)

type spkey [bounded].
type sskey [bounded].
type skeyseed [large,fixed].
type sseed [fixed].
type signature [bounded].
type sblocksize [bounded].

proba Psign.
proba Psigncoll.

expand UF_CMA_signature(skeyseed, spkey, sskey, sblocksize, signature, sseed, sk, vk, sign, check, Psign, Psigncoll).

fun cert(fixed_100_key, bounded_40_host): sblocksize [compos].

fun check_key(bounded_40_host, fixed_100_key, signature, spkey): bool.

forall h: bounded_40_host, k: fixed_100_key, sig: signature, pkS: spkey;
  check_key(h, k, sig, pkS) = check(cert(k, h), pkS, sig).


(*************************** 
  Formatting Functions 
***************************)

(* conc1 := "msg1"|(len(arg0))^[u,8]|arg0|arg1 *)
fun conc1(fixed_20_nonce, bounded_40_host): bounded_200_cleartext [compos].

(* conc2 := "msg3"|arg0 *)
fun conc2(fixed_20_nonce): bounded_200_cleartext [compos].

(* conc3 := "msg2"|(len(arg0))^[u,8]|(len(arg1))^[u,8]|arg0|arg1|arg2 *)
fun conc3(fixed_20_nonce, fixed_20_nonce, bounded_40_host): bounded_200_cleartext [compos].


forall var1: fixed_20_nonce, var2: fixed_20_nonce, var3: fixed_20_nonce, var4: bounded_40_host;
  conc2(var1) <> conc3(var2, var3, var4).
forall var1: fixed_20_nonce, var2: bounded_40_host, var3: fixed_20_nonce, var4: fixed_20_nonce, var5: bounded_40_host;
  conc1(var1, var2) <> conc3(var3, var4, var5).
forall var1: fixed_20_nonce, var2: bounded_40_host, var3: fixed_20_nonce;
  conc1(var1, var2) <> conc2(var3).

(*************************** 
  Parsing Equations 
***************************)


(*************************** 
  Arithmetic Functions 
***************************)

(* arithmetic1 := (len(arg0))^[u,8] *)
fun arithmetic1(bounded_1000_ciphertext): bitstring.


(*************************** 
  Auxiliary Tests 
***************************)

(* cond1 := ¬((arg0)_[s,8] <= 0) *)
fun cond1(bitstring): bool.

(* cond10 := 0 < (arg0)_[u,8] *)
fun cond10(bitstring): bool.

(* cond11 := ¬((arg0)_[u,8] < 7) *)
fun cond11(bitstring): bool.

(* cond12 := ¬(len(arg0) > ((arg1)_[u,8] - 7)) *)
fun cond12(bounded_200_cleartext, bitstring): bool.

(* cond13 := ¬((len(arg0) + 40 + (2 * 8) + 4) <> len(arg1)) *)
fun cond13(bounded_40_host, bounded_200_cleartext): bool.

(* cond14 := arg0{0, 4} = "msg2" *)
fun cond14(bounded_200_cleartext): bool.

(* cond15 := ¬((arg0{4, 8})_[u,8] <> 20) *)
fun cond15(bounded_200_cleartext): bool.

(* cond16 := ¬((arg0{4 + 8, 8})_[u,8] <> 20) *)
fun cond16(bounded_200_cleartext): bool.

(* cond17 := ¬(len(arg0) > (7 + 4 + (arg1{4 + 8, 8})_[u,8])) *)
fun cond17(bounded_1000_ciphertext, bounded_200_cleartext): bool.

(* cond18 := 0 < len(arg0) *)
fun cond18(bounded_1000_ciphertext): bool.

(* cond19 := ¬((arg0)_[s,8] <= 0) *)
fun cond19(bitstring): bool.

(* cond20 := ¬((arg0)_[s,8] <= 0) *)
fun cond20(bitstring): bool.

(* cond24 := ¬((arg0)_[u,8] > 1000) *)
fun cond24(bitstring): bool.

(* cond25 := 0 < (arg0)_[u,8] *)
fun cond25(bitstring): bool.

(* cond26 := ¬((arg0)_[u,8] < 7) *)
fun cond26(bitstring): bool.

(* cond27 := ¬(len(arg0) > ((arg1)_[u,8] - 7)) *)
fun cond27(bounded_200_cleartext, bitstring): bool.

(* cond28 := ¬((8 + 20 + 4) >= len(arg0)) *)
fun cond28(bounded_200_cleartext): bool.

(* cond29 := arg0{0, 4} = "msg1" *)
fun cond29(bounded_200_cleartext): bool.

(* cond30 := ¬((arg0{4, 8})_[u,8] <> 20) *)
fun cond30(bounded_200_cleartext): bool.

(* cond31 := ¬((len(arg0) - (4 + 8 + (arg0{4, 8})_[u,8])) > 40) *)
fun cond31(bounded_200_cleartext): bool.

(* cond33 := ¬(len(arg0) > (7 + 40 + (2 * 8) + 4 + len(arg1))) *)
fun cond33(bounded_1000_ciphertext, bounded_40_host): bool.

(* cond34 := 0 < len(arg0) *)
fun cond34(bounded_1000_ciphertext): bool.

(* cond35 := ¬((arg0)_[u,8] > 1000) *)
fun cond35(bitstring): bool.

(* cond36 := 0 < (arg0)_[u,8] *)
fun cond36(bitstring): bool.

(* cond37 := ¬((arg0)_[u,8] < 7) *)
fun cond37(bitstring): bool.

(* cond38 := ¬(len(arg0) > ((arg1)_[u,8] - 7)) *)
fun cond38(bounded_200_cleartext, bitstring): bool.

(* cond39 := arg0{0, 4} = "msg3" *)
fun cond39(bounded_200_cleartext): bool.

(* cond40 := ¬(len(arg0) <> 24) *)
fun cond40(bounded_200_cleartext): bool.

(* cond7 := ¬(len(arg0) > (7 + 24 + len(arg1) + 8)) *)
fun cond7(bounded_1000_ciphertext, bounded_40_host): bool.

(* cond8 := 0 < len(arg0) *)
fun cond8(bounded_1000_ciphertext): bool.

(* cond9 := ¬((arg0)_[u,8] > 1000) *)
fun cond9(bitstring): bool.


(*************************** 
  Zero Functions 
***************************)

fun Zbitstring(bitstring): bitstring.

fun Zbitstring_prime(bitstring): bitstring.

fun Zbounded_1000_ciphertext(bounded_1000_ciphertext): bounded_1000_ciphertext.

fun Zbounded_1000_ciphertext_prime(bounded_1000_ciphertext): bounded_1000_ciphertext.

(* Zbounded_200_cleartext is already defined in the template *)

fun Zbounded_200_cleartext_prime(bounded_200_cleartext): bounded_200_cleartext.

fun Zbounded_40_host(bounded_40_host): bounded_40_host.

fun Zbounded_40_host_prime(bounded_40_host): bounded_40_host.

fun Zfixed_100_key(fixed_100_key): fixed_100_key.

fun Zfixed_100_key_prime(fixed_100_key): fixed_100_key.

fun Zfixed_20_nonce(fixed_20_nonce): fixed_20_nonce.

fun Zfixed_20_nonce_prime(fixed_20_nonce): fixed_20_nonce.

fun Zfixed_256_seed_T(fixed_256_seed_T): fixed_256_seed_T.

fun Zfixed_256_seed_T_prime(fixed_256_seed_T): fixed_256_seed_T.

const zero_fixed_100_key: fixed_100_key.

const zero_fixed_20_nonce: fixed_20_nonce.

const zero_fixed_256_seed_T: fixed_256_seed_T.


(*************************** 
  Primed Functions 
***************************)

fun cond8_prime(bounded_1000_ciphertext): bool.

fun cond7_prime(bounded_1000_ciphertext, bounded_40_host): bool.

fun cond40_prime(bounded_200_cleartext): bool.

fun cond38_prime(bounded_200_cleartext, bitstring): bool.

fun cond34_prime(bounded_1000_ciphertext): bool.

fun cond33_prime(bounded_1000_ciphertext, bounded_40_host): bool.

fun cond28_prime(bounded_200_cleartext): bool.

fun cond27_prime(bounded_200_cleartext, bitstring): bool.

fun cond18_prime(bounded_1000_ciphertext): bool.

fun cond17_prime(bounded_1000_ciphertext, bounded_200_cleartext): bool.

fun conc3_prime(fixed_20_nonce, fixed_20_nonce, bounded_40_host): bounded_200_cleartext.

fun conc2_prime(fixed_20_nonce): bounded_200_cleartext.

fun conc1_prime(fixed_20_nonce, bounded_40_host): bounded_200_cleartext.

fun cond13_prime(bounded_40_host, bounded_200_cleartext): bool.

fun cond12_prime(bounded_200_cleartext, bitstring): bool.


(*************************** 
  Typecasting 
***************************)

fun cast_bitstring_bounded_1000_ciphertext(bitstring): bounded_1000_ciphertext [compos].

(*************************** 
  Auxiliary Facts 
***************************)

forall arg0: bounded_1000_ciphertext;
	cond8(arg0) = cond8_prime(Zbounded_1000_ciphertext(arg0)).
forall arg1: bounded_40_host, arg0: bounded_1000_ciphertext;
	cond7(arg0, arg1) = cond7_prime(Zbounded_1000_ciphertext(arg0), Zbounded_40_host(arg1)).
forall arg0: bounded_200_cleartext;
	cond40(arg0) = cond40_prime(Zbounded_200_cleartext(arg0)).
forall x139: bounded_40_host, x138: fixed_20_nonce, x137: fixed_20_nonce;
	cond39(conc3(x137, x138, x139)) = cond39(conc3_prime(Zfixed_20_nonce(x137), Zfixed_20_nonce(x138), Zbounded_40_host(x139))).
forall x140: fixed_20_nonce;
	cond39(conc2(x140)) = cond39(conc2_prime(Zfixed_20_nonce(x140))).
forall x142: bounded_40_host, x141: fixed_20_nonce;
	cond39(conc1(x141, x142)) = cond39(conc1_prime(Zfixed_20_nonce(x141), Zbounded_40_host(x142))).
forall arg1: bitstring, arg0: bounded_200_cleartext;
	cond38(arg0, arg1) = cond38_prime(Zbounded_200_cleartext(arg0), arg1).
forall arg0: bounded_1000_ciphertext;
	cond34(arg0) = cond34_prime(Zbounded_1000_ciphertext(arg0)).
forall arg1: bounded_40_host, arg0: bounded_1000_ciphertext;
	cond33(arg0, arg1) = cond33_prime(Zbounded_1000_ciphertext(arg0), Zbounded_40_host(arg1)).
forall x163: bounded_40_host, x162: fixed_20_nonce, x161: fixed_20_nonce;
	cond31(conc3(x161, x162, x163)) = cond31(conc3_prime(Zfixed_20_nonce(x161), Zfixed_20_nonce(x162), Zbounded_40_host(x163))).
forall x166: bounded_40_host, x165: fixed_20_nonce;
	cond31(conc1(x165, x166)) = cond31(conc1_prime(Zfixed_20_nonce(x165), Zbounded_40_host(x166))).
forall x171: bounded_40_host, x170: fixed_20_nonce, x169: fixed_20_nonce;
	cond30(conc3(x169, x170, x171)) = cond30(conc3_prime(Zfixed_20_nonce(x169), Zfixed_20_nonce(x170), Zbounded_40_host(x171))).
forall x174: bounded_40_host, x173: fixed_20_nonce;
	cond30(conc1(x173, x174)) = cond30(conc1_prime(Zfixed_20_nonce(x173), Zbounded_40_host(x174))).
forall x179: bounded_40_host, x178: fixed_20_nonce, x177: fixed_20_nonce;
	cond29(conc3(x177, x178, x179)) = cond29(conc3_prime(Zfixed_20_nonce(x177), Zfixed_20_nonce(x178), Zbounded_40_host(x179))).
forall x180: fixed_20_nonce;
	cond29(conc2(x180)) = cond29(conc2_prime(Zfixed_20_nonce(x180))).
forall x182: bounded_40_host, x181: fixed_20_nonce;
	cond29(conc1(x181, x182)) = cond29(conc1_prime(Zfixed_20_nonce(x181), Zbounded_40_host(x182))).
forall arg0: bounded_200_cleartext;
	cond28(arg0) = cond28_prime(Zbounded_200_cleartext(arg0)).
forall arg1: bitstring, arg0: bounded_200_cleartext;
	cond27(arg0, arg1) = cond27_prime(Zbounded_200_cleartext(arg0), arg1).
forall arg0: bounded_1000_ciphertext;
	cond18(arg0) = cond18_prime(Zbounded_1000_ciphertext(arg0)).
forall arg1: bounded_200_cleartext, arg0: bounded_1000_ciphertext;
	cond17(arg0, arg1) = cond17_prime(Zbounded_1000_ciphertext(arg0), arg1).
forall x207: bounded_40_host, x206: fixed_20_nonce, x205: fixed_20_nonce, arg0: bounded_1000_ciphertext;
	cond17_prime(arg0, conc3(x205, x206, x207)) = cond17_prime(arg0, conc3_prime(Zfixed_20_nonce(x205), Zfixed_20_nonce(x206), Zbounded_40_host(x207))).
forall x215: bounded_40_host, x214: fixed_20_nonce, x213: fixed_20_nonce;
	cond16(conc3(x213, x214, x215)) = cond16(conc3_prime(Zfixed_20_nonce(x213), Zfixed_20_nonce(x214), Zbounded_40_host(x215))).
forall x223: bounded_40_host, x222: fixed_20_nonce, x221: fixed_20_nonce;
	cond15(conc3(x221, x222, x223)) = cond15(conc3_prime(Zfixed_20_nonce(x221), Zfixed_20_nonce(x222), Zbounded_40_host(x223))).
forall x226: bounded_40_host, x225: fixed_20_nonce;
	cond15(conc1(x225, x226)) = cond15(conc1_prime(Zfixed_20_nonce(x225), Zbounded_40_host(x226))).
forall x231: bounded_40_host, x230: fixed_20_nonce, x229: fixed_20_nonce;
	cond14(conc3(x229, x230, x231)) = cond14(conc3_prime(Zfixed_20_nonce(x229), Zfixed_20_nonce(x230), Zbounded_40_host(x231))).
forall x232: fixed_20_nonce;
	cond14(conc2(x232)) = cond14(conc2_prime(Zfixed_20_nonce(x232))).
forall x234: bounded_40_host, x233: fixed_20_nonce;
	cond14(conc1(x233, x234)) = cond14(conc1_prime(Zfixed_20_nonce(x233), Zbounded_40_host(x234))).
forall arg1: bounded_200_cleartext, arg0: bounded_40_host;
	cond13(arg0, arg1) = cond13_prime(Zbounded_40_host(arg0), Zbounded_200_cleartext(arg1)).
forall arg1: bitstring, arg0: bounded_200_cleartext;
	cond12(arg0, arg1) = cond12_prime(Zbounded_200_cleartext(arg0), arg1).

(*************************** 
  Zero Facts 
***************************)

forall arg2: bounded_40_host, arg1: fixed_20_nonce, arg0: fixed_20_nonce;
	Zbounded_200_cleartext(conc3(arg0, arg1, arg2)) = Zbounded_200_cleartext_prime(conc3(Zfixed_20_nonce(arg0), Zfixed_20_nonce(arg1), Zbounded_40_host(arg2))).
forall arg0: fixed_20_nonce;
	Zbounded_200_cleartext(conc2(arg0)) = Zbounded_200_cleartext_prime(conc2(Zfixed_20_nonce(arg0))).
forall arg1: bounded_40_host, arg0: fixed_20_nonce;
	Zbounded_200_cleartext(conc1(arg0, arg1)) = Zbounded_200_cleartext_prime(conc1(Zfixed_20_nonce(arg0), Zbounded_40_host(arg1))).
forall x: bitstring;
	Zbounded_1000_ciphertext(cast_bitstring_bounded_1000_ciphertext(x)) = Zbounded_1000_ciphertext_prime(cast_bitstring_bounded_1000_ciphertext(Zbitstring(x))).
forall x: fixed_20_nonce;
	Zfixed_20_nonce(x) = zero_fixed_20_nonce().
forall x: fixed_256_seed_T;
	Zfixed_256_seed_T(x) = zero_fixed_256_seed_T().
forall x: fixed_100_key;
	Zfixed_100_key(x) = zero_fixed_100_key().

(******************** 
  <Query>
********************)
 
event client_begin(bounded_40_host, bounded_40_host).
event server_begin(bounded_40_host, bounded_40_host).
event client_end(bounded_40_host, bounded_40_host).
event server_end(bounded_40_host, bounded_40_host).
event bad(bounded_40_host).

(* na: nonce, nb: nonce *)
query x: bounded_40_host, y: bounded_40_host;
  event server_end(x, y) ==> client_begin(x, y) || bad(x).

query x: bounded_40_host, y: bounded_40_host;
  event client_end(x, y) ==> server_begin(x, y) || bad(y).


(*************************** 
  Model 
***************************)

let client = 
in(c_in, (var1: bitstring, BIO_ctrl_result1: bitstring));
if cond1(BIO_ctrl_result1) then 
if check_key(hostX, pkX, sigX, pkS) then 
event client_begin(hostA, hostX);
new nonce1: fixed_20_nonce;
let msg1 = conc1(nonce1, hostA) in
let key3 = isek(pkX) in
new nonce2: fixed_256_seed_T;
let msg3 = E(msg1, key3, nonce2) in
if cond7(msg3, hostA) then 
let msg2 = arithmetic1(msg3) in
if cond8(msg3) then 
out(c_out, (msg3, msg2));
in(c_in, (msg4: bitstring, cipher2: bitstring));
if cond9(msg4) then 
if cond10(msg4) then 
if cond11(msg4) then 
let injbot(msg6) = D(cast_bitstring_bounded_1000_ciphertext(cipher2), skA) in
if cond12(msg6, msg4) then 
if cond13(hostX, msg6) then 
if cond14(msg6) then 
if cond15(msg6) then 
if cond16(msg6) then 
let conc3(var39, var43, var41) = msg6 in
let var40 = var39 in
if var40 = nonce1 then 
let var42 = var41 in
if var42 = hostX then 
let var44 = var43 in
let msg7 = conc2(var44) in
new nonce3: fixed_256_seed_T;
let msg9 = E(msg7, key3, nonce3) in
if cond17(msg9, msg6) then 
let msg8 = arithmetic1(msg9) in
if cond18(msg9) then 
event client_end(hostA, hostX);
out(c_out, (msg9, msg8)); 0 .

let server = 
in(c_in, (var8: bitstring, BIO_ctrl_result2: bitstring, BIO_ctrl_result3: bitstring, var11: bitstring, var12: bitstring, msg10: bitstring, cipher4: bitstring));
if cond19(BIO_ctrl_result2) then 
if cond20(BIO_ctrl_result3) then 
if cond24(msg10) then 
if cond25(msg10) then 
if cond26(msg10) then 
let injbot(msg12) = D(cast_bitstring_bounded_1000_ciphertext(cipher4), skB) in
if cond27(msg12, msg10) then 
if cond28(msg12) then 
if cond29(msg12) then 
if cond30(msg12) then 
if cond31(msg12) then 
let conc1(var24, host2) = msg12 in
if check_key(host2, pkX, sigX, pkS) then 
event server_begin(host2, hostB);
new nonce4: fixed_20_nonce;
let var25 = var24 in
let msg13 = conc3(var25, nonce4, hostB) in
let key10 = isek(pkX) in
new nonce5: fixed_256_seed_T;
let msg15 = E(msg13, key10, nonce5) in
if cond33(msg15, hostB) then 
let msg14 = arithmetic1(msg15) in
if cond34(msg15) then 
out(c_out, (msg15, msg14));
in(c_in, (msg16: bitstring, cipher6: bitstring));
if cond35(msg16) then 
if cond36(msg16) then 
if cond37(msg16) then 
let injbot(msg18) = D(cast_bitstring_bounded_1000_ciphertext(cipher6), skB) in
if cond38(msg18, msg16) then 
if cond39(msg18) then 
if cond40(msg18) then 
let conc2(var31) = msg18 in
let var32 = var31 in
if var32 = nonce4 then 
event server_end(host2, hostB);
yield .

(*************************** 
  <Environment>
***************************)

let client' = 
  in(c_in, (pkX: fixed_100_key, hostX: bounded_40_host, sigX: signature));
  out(c_out, ());
  client .

let server' = 
  in(c_in, (pkX: fixed_100_key, sigX: signature));
  out(c_out, ());
  server .

let keyServer = 
  in(c_in, (h: bounded_40_host, k: fixed_100_key));
  let rk = 
    if h = hostA then pkA else
    if h = hostB then pkB else
    k in
  new r3: sseed;
  let cert = (rk, h, sign(cert(rk, h), skS, r3)) in
  if h = hostA || h = hostB then
    out(c_out, cert)
  else
    event bad(h);
    out(c_out, cert) .

process
! N (
  in(c_in, ());
  new A_seed: keyseed_T; 
  new B_seed: keyseed_T;
  let pkA = ek(A_seed) in
  let skA = dk(A_seed) in
  let pkB = ek(B_seed) in
  let skB = dk(B_seed) in

  new rkS: skeyseed;
  let pkS = vk(rkS) in
  let skS = sk(rkS) in
  
  out(c_out, (pkA, pkB, pkS));
  ((! N client') | (! N server') | (! N keyServer))
)


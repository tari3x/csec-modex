
(**********************************
  RPC-enc protocol.
***********************************)

param N.

channel c_in, c_out.

type nondet [fixed].

(********************************
  IND-CPA INT-CTXT encryption
*********************************)

type fixed_16_keyseed [fixed, large].
(*
  Must be bounded because the security definition refers
  to time(kgen).
*)
type fixed_16_key [bounded].
type fixed_16_seed [fixed, large].

(* 1049 = 1024 for payload + 16 for key + 4 for payload length + 1 for tag *)
type bounded_1045_plaintext [bounded].
(*
  Encryption adds 32 bytes to the message.
*)
type bounded_1077_ciphertext  [bounded].

proba Penc.
proba Pencptxt.
proba Pencctxt.

expand IND_CPA_INT_CTXT_sym_enc(fixed_16_keyseed, fixed_16_key, bounded_1045_plaintext, bounded_1077_ciphertext, fixed_16_seed, 
                                kgen, E, D, injbot, Zbounded_1045_plaintext, Penc, Pencctxt). 

fun inverse_injbot(bitstringbot): bounded_1045_plaintext.

(*************************** 
  Key lookup
***************************)

type keydb.
type bounded_1024_id.

(* the ids of a designated pair of honest participants *)
const clientID: bounded_1024_id.
const serverID: bounded_1024_id. 

(* key database operations *)
fun add_honest(fixed_16_key, keydb): keydb.
(* Returns some fixed default value if key not in the database. *)
fun lookup(bounded_1024_id, bounded_1024_id, keydb): fixed_16_key.

forall k: fixed_16_key, db: keydb;
  lookup(clientID, serverID, add_honest(k, db)) = k.

(* a host id that carries along the fact that it is compromised *)
fun badHost(bounded_1024_id): bounded_1024_id [compos].

(*
  It is important that in the bad host branch we remove the mention of the honest key,
  so we can show that it isn't leaked anywhere.
*)
forall h:bounded_1024_id, k: fixed_16_key, db: keydb;
  lookup(badHost(h), serverID, add_honest(k, db)) = lookup(badHost(h), serverID, db).

(********************************
  Misc
*********************************)

type fixed_1024_payload [fixed, large]. 

(* The port that the server is listening to. *)
const port: bitstring.


(*************************** 
  Formatting Functions 
***************************)

(* conc1 := "p"|(len(arg0))^[u,4]|arg0|arg1 *)
fun conc1(fixed_1024_payload, fixed_16_key): bounded_1045_plaintext [compos].

(* conc2 := "p"|(len(arg0))^[u,4]|arg0|arg1 *)
fun conc2(bounded_1024_id, bounded_1077_ciphertext): bitstring [compos].



(*************************** 
  Parsing Equations 
***************************)


(*************************** 
  Arithmetic Functions 
***************************)

(* arithmetic1 := CastToInt((((1)^[u,8] + (4)^[u,8]) + (len(arg0))^[u,8]) + (len(arg1))^[u,8]) *)
fun arithmetic1(bounded_1024_id, bounded_1077_ciphertext): bitstring.

(* arithmetic2 := (len(arg0))^[u,4] *)
fun arithmetic2(bounded_1077_ciphertext): bitstring.


(*************************** 
  Auxiliary Tests 
***************************)

(* cond12 := ¬(len(arg0) = 0) *)
fun cond12(bounded_1077_ciphertext): bool.

(* cond13 := ¬((arg0)_[u,4] < 1056) *)
fun cond13(bitstring): bool.

(* cond14 := ¬((arg0)_[u,4] > 1056) *)
fun cond14(bitstring): bool.

(* cond15 := ¬(len(arg0) > ((arg1)_[u,4] - 32)) *)
fun cond15(bounded_1045_plaintext, bitstring): bool.

(* cond16 := ¬(len(arg0) = 0) *)
fun cond16(bounded_1045_plaintext): bool.

(* cond17 := ¬(len(arg0) < 1024) *)
fun cond17(bounded_1045_plaintext): bool.

(* cond19 := ¬(len(arg0) >= 256) *)
fun cond19(bounded_1024_id): bool.

(* cond20 := ¬(len(arg0) = 0) *)
fun cond20(bounded_1024_id): bool.

(* cond21 := ¬((arg0)_[s,4] <> 0) *)
fun cond21(bitstring): bool.

(* cond22 := ¬((arg0)_[s,4] <> 0) *)
fun cond22(bitstring): bool.

(* cond23 := ¬((arg0)_[u,4] < (1040 + 4 + 1 + 32 + 4 + 1)) *)
fun cond23(bitstring): bool.

(* cond24 := ¬((arg0)_[u,4] > (1040 + 4 + 1 + 32 + 1024 + 4 + 1)) *)
fun cond24(bitstring): bool.

(* cond25 := "p" = arg0{0, 1} *)
fun cond25(bitstring): bool.

(* cond26 := ¬((arg0{1, 4})_[u,4] > 1024) *)
fun cond26(bitstring): bool.

(* cond27 := ¬(((arg0)_[u,4] - (1 + 4 + (arg1{1, 4})_[u,4])) > (1040 + 4 + 1 + 32)) *)
fun cond27(bitstring, bitstring): bool.

(* cond28 := ¬((arg0{1, 4})_[u,4] <> len(arg1)) *)
fun cond28(bitstring, bounded_1024_id): bool.

(* cond29 := ¬(len(arg0) > ((arg1)_[u,4] - (1 + 4 + (arg2{1, 4})_[u,4] + 32))) *)
fun cond29(bounded_1045_plaintext, bitstring, bitstring): bool.

(* cond3 := ¬(len(arg0) = 0) *)
fun cond3(bounded_1024_id): bool.

(* cond30 := ¬(len(arg0) < (1 + 4)) *)
fun cond30(bounded_1045_plaintext): bool.

(* cond31 := ¬((arg0{1, 4})_[u,4] > 1024) *)
fun cond31(bounded_1045_plaintext): bool.

(* cond32 := ¬((arg0{1, 4})_[u,4] < 1024) *)
fun cond32(bounded_1045_plaintext): bool.

(* cond33 := ¬(len(arg0) <= (1 + 4 + (arg0{1, 4})_[u,4])) *)
fun cond33(bounded_1045_plaintext): bool.

(* cond34 := "p" = arg0{0, 1} *)
fun cond34(bounded_1045_plaintext): bool.

(* cond35 := ¬((len(arg0) - (1 + 4 + (arg0{1, 4})_[u,4])) <> 16) *)
fun cond35(bounded_1045_plaintext): bool.

(* cond38 := ¬(len(arg0) > (32 + len(arg1))) *)
fun cond38(bounded_1077_ciphertext, fixed_1024_payload): bool.

(* cond39 := ¬(len(arg0) = 0) *)
fun cond39(bounded_1077_ciphertext): bool.

(* cond4 := ¬(len(arg0) = 0) *)
fun cond4(bounded_1024_id): bool.

(* cond7 := ¬((arg0)_[s,4] <> 0) *)
fun cond7(bitstring): bool.

(* cond8 := ¬(Truth_of_bs(arg0)) *)
fun cond8(bitstring): bool.

(* cond9 := ¬(len(arg0) <> len(arg1)) *)
fun cond9(bounded_1024_id, bounded_1024_id): bool.


(*************************** 
  Zero Functions 
***************************)

fun Zbitstring(bitstring): bitstring.

fun Zbitstring_prime(bitstring): bitstring.

fun Zbounded_1024_id(bounded_1024_id): bounded_1024_id.

fun Zbounded_1024_id_prime(bounded_1024_id): bounded_1024_id.

(* Zbounded_1045_plaintext is already defined in the template *)

fun Zbounded_1045_plaintext_prime(bounded_1045_plaintext): bounded_1045_plaintext.

fun Zbounded_1077_ciphertext(bounded_1077_ciphertext): bounded_1077_ciphertext.

fun Zbounded_1077_ciphertext_prime(bounded_1077_ciphertext): bounded_1077_ciphertext.

fun Zfixed_1024_payload(fixed_1024_payload): fixed_1024_payload.

fun Zfixed_1024_payload_prime(fixed_1024_payload): fixed_1024_payload.

fun Zfixed_16_key(fixed_16_key): fixed_16_key.

fun Zfixed_16_key_prime(fixed_16_key): fixed_16_key.

fun Zfixed_16_keyseed(fixed_16_keyseed): fixed_16_keyseed.

fun Zfixed_16_keyseed_prime(fixed_16_keyseed): fixed_16_keyseed.

fun Zfixed_16_seed(fixed_16_seed): fixed_16_seed.

fun Zfixed_16_seed_prime(fixed_16_seed): fixed_16_seed.

const zero_fixed_1024_payload: fixed_1024_payload.

const zero_fixed_16_key: fixed_16_key.

const zero_fixed_16_keyseed: fixed_16_keyseed.

const zero_fixed_16_seed: fixed_16_seed.


(*************************** 
  Primed Functions 
***************************)

fun cond9_prime(bounded_1024_id, bounded_1024_id): bool.

fun cond4_prime(bounded_1024_id): bool.

fun cond39_prime(bounded_1077_ciphertext): bool.

fun cond38_prime(bounded_1077_ciphertext, fixed_1024_payload): bool.

fun conc1_prime(fixed_1024_payload, fixed_16_key): bounded_1045_plaintext.

fun cond30_prime(bounded_1045_plaintext): bool.

fun cond3_prime(bounded_1024_id): bool.

fun cond29_prime(bounded_1045_plaintext, bitstring, bitstring): bool.

fun cond28_prime(bitstring, bounded_1024_id): bool.

fun conc2_prime(bounded_1024_id, bounded_1077_ciphertext): bitstring.

fun cond20_prime(bounded_1024_id): bool.

fun cond19_prime(bounded_1024_id): bool.

fun cond17_prime(bounded_1045_plaintext): bool.

fun cond16_prime(bounded_1045_plaintext): bool.

fun cond15_prime(bounded_1045_plaintext, bitstring): bool.

fun cond12_prime(bounded_1077_ciphertext): bool.


(*************************** 
  Typecasting 
***************************)

fun cast_bitstring_bounded_1077_ciphertext(bitstring): bounded_1077_ciphertext [compos].
fun cast_bounded_1045_plaintext_fixed_1024_payload(bounded_1045_plaintext): fixed_1024_payload [compos].
fun cast_fixed_1024_payload_bounded_1045_plaintext(fixed_1024_payload): bounded_1045_plaintext [compos].
forall x: fixed_1024_payload;
  cast_bounded_1045_plaintext_fixed_1024_payload(cast_fixed_1024_payload_bounded_1045_plaintext(x)) = x.

(*************************** 
  Auxiliary Facts 
***************************)

forall arg1: bounded_1024_id, arg0: bounded_1024_id;
	cond9(arg0, arg1) = cond9_prime(Zbounded_1024_id(arg0), Zbounded_1024_id(arg1)).
forall arg0: bounded_1024_id;
	cond4(arg0) = cond4_prime(Zbounded_1024_id(arg0)).
forall arg0: bounded_1077_ciphertext;
	cond39(arg0) = cond39_prime(Zbounded_1077_ciphertext(arg0)).
forall arg1: fixed_1024_payload, arg0: bounded_1077_ciphertext;
	cond38(arg0, arg1) = cond38_prime(Zbounded_1077_ciphertext(arg0), Zfixed_1024_payload(arg1)).
forall x140: fixed_16_key, x139: fixed_1024_payload;
	cond35(conc1(x139, x140)) = cond35(conc1_prime(Zfixed_1024_payload(x139), Zfixed_16_key(x140))).
forall x144: fixed_16_key, x143: fixed_1024_payload;
	cond34(conc1(x143, x144)) = cond34(conc1_prime(Zfixed_1024_payload(x143), Zfixed_16_key(x144))).
forall x148: fixed_16_key, x147: fixed_1024_payload;
	cond33(conc1(x147, x148)) = cond33(conc1_prime(Zfixed_1024_payload(x147), Zfixed_16_key(x148))).
forall x152: fixed_16_key, x151: fixed_1024_payload;
	cond32(conc1(x151, x152)) = cond32(conc1_prime(Zfixed_1024_payload(x151), Zfixed_16_key(x152))).
forall x156: fixed_16_key, x155: fixed_1024_payload;
	cond31(conc1(x155, x156)) = cond31(conc1_prime(Zfixed_1024_payload(x155), Zfixed_16_key(x156))).
forall arg0: bounded_1045_plaintext;
	cond30(arg0) = cond30_prime(Zbounded_1045_plaintext(arg0)).
forall arg0: bounded_1024_id;
	cond3(arg0) = cond3_prime(Zbounded_1024_id(arg0)).
forall arg2: bitstring, arg1: bitstring, arg0: bounded_1045_plaintext;
	cond29(arg0, arg1, arg2) = cond29_prime(Zbounded_1045_plaintext(arg0), arg1, arg2).
forall x170: bounded_1077_ciphertext, x169: bounded_1024_id, arg1: bitstring, arg0: bounded_1045_plaintext;
	cond29_prime(arg0, arg1, conc2(x169, x170)) = cond29_prime(arg0, arg1, conc2_prime(Zbounded_1024_id(x169), Zbounded_1077_ciphertext(x170))).
forall arg1: bounded_1024_id, arg0: bitstring;
	cond28(arg0, arg1) = cond28_prime(arg0, Zbounded_1024_id(arg1)).
forall x175: bounded_1077_ciphertext, x174: bounded_1024_id, arg1: bounded_1024_id;
	cond28_prime(conc2(x174, x175), arg1) = cond28_prime(conc2_prime(Zbounded_1024_id(x174), Zbounded_1077_ciphertext(x175)), arg1).
forall x184: bounded_1077_ciphertext, x183: bounded_1024_id, arg0: bitstring;
	cond27(arg0, conc2(x183, x184)) = cond27(arg0, conc2_prime(Zbounded_1024_id(x183), Zbounded_1077_ciphertext(x184))).
forall x188: bounded_1077_ciphertext, x187: bounded_1024_id;
	cond26(conc2(x187, x188)) = cond26(conc2_prime(Zbounded_1024_id(x187), Zbounded_1077_ciphertext(x188))).
forall x192: bounded_1077_ciphertext, x191: bounded_1024_id;
	cond25(conc2(x191, x192)) = cond25(conc2_prime(Zbounded_1024_id(x191), Zbounded_1077_ciphertext(x192))).
forall arg0: bounded_1024_id;
	cond20(arg0) = cond20_prime(Zbounded_1024_id(arg0)).
forall arg0: bounded_1024_id;
	cond19(arg0) = cond19_prime(Zbounded_1024_id(arg0)).
forall arg0: bounded_1045_plaintext;
	cond17(arg0) = cond17_prime(Zbounded_1045_plaintext(arg0)).
forall arg0: bounded_1045_plaintext;
	cond16(arg0) = cond16_prime(Zbounded_1045_plaintext(arg0)).
forall arg1: bitstring, arg0: bounded_1045_plaintext;
	cond15(arg0, arg1) = cond15_prime(Zbounded_1045_plaintext(arg0), arg1).
forall arg0: bounded_1077_ciphertext;
	cond12(arg0) = cond12_prime(Zbounded_1077_ciphertext(arg0)).

(*************************** 
  Zero Facts 
***************************)

forall arg1: bounded_1077_ciphertext, arg0: bounded_1024_id;
	Zbitstring(conc2(arg0, arg1)) = Zbitstring_prime(conc2(Zbounded_1024_id(arg0), Zbounded_1077_ciphertext(arg1))).
forall arg1: fixed_16_key, arg0: fixed_1024_payload;
	Zbounded_1045_plaintext(conc1(arg0, arg1)) = Zbounded_1045_plaintext_prime(conc1(Zfixed_1024_payload(arg0), Zfixed_16_key(arg1))).
forall x: bitstring;
	Zbounded_1077_ciphertext(cast_bitstring_bounded_1077_ciphertext(x)) = Zbounded_1077_ciphertext_prime(cast_bitstring_bounded_1077_ciphertext(Zbitstring(x))).
forall x: bounded_1045_plaintext;
	Zfixed_1024_payload(cast_bounded_1045_plaintext_fixed_1024_payload(x)) = Zfixed_1024_payload_prime(cast_bounded_1045_plaintext_fixed_1024_payload(Zbounded_1045_plaintext(x))).
forall x: fixed_1024_payload;
	Zbounded_1045_plaintext(cast_fixed_1024_payload_bounded_1045_plaintext(x)) = Zbounded_1045_plaintext_prime(cast_fixed_1024_payload_bounded_1045_plaintext(Zfixed_1024_payload(x))).
forall x: fixed_1024_payload;
	Zfixed_1024_payload(x) = zero_fixed_1024_payload().
forall x: fixed_16_keyseed;
	Zfixed_16_keyseed(x) = zero_fixed_16_keyseed().
forall x: fixed_16_key;
	Zfixed_16_key(x) = zero_fixed_16_key().
forall x: fixed_16_seed;
	Zfixed_16_seed(x) = zero_fixed_16_seed().

(********************************
  <Query>
*********************************)

event client_begin(bounded_1024_id, bounded_1024_id, fixed_1024_payload).
event client_accept(bounded_1024_id, bounded_1024_id, fixed_1024_payload, fixed_1024_payload).
event server_reply(bounded_1024_id, bounded_1024_id, fixed_1024_payload, fixed_1024_payload).
event bad(bounded_1024_id).

(* Authentication of the server to the client *)
query hClient: bounded_1024_id, hServer: bounded_1024_id, x: fixed_1024_payload, y: fixed_1024_payload;
  event client_accept(hClient, hServer, x, y) ==> server_reply(hClient, hServer, x, y).

(* Authentication of the client to the server *)
query hClient: bounded_1024_id, hServer: bounded_1024_id, x: fixed_1024_payload, y: fixed_1024_payload;
  event server_reply(hClient, hServer, x, y) ==> client_begin(hClient, hServer, x) || bad(hClient).

(* Strong secrecy of the request *)
query secret request.

(* Weak conditional secrecy of the response *)
event leaked(bounded_1024_id, fixed_1024_payload).
query hClient: bounded_1024_id, resp: fixed_1024_payload;
  event leaked(hClient, resp) ==> bad(hClient).


(*************************** 
  Model 
***************************)

let client = 
in(c_in, ());
if cond3(clientID) then 
if cond4(serverID) then 
out(c_out, (port, serverID));
in(c_in, net_connect_result1: bitstring);
if cond7(net_connect_result1) then 
if cond8(net_connect_result1) then 
if cond9(clientID, xClient) then 
if clientID = xClient then 
let key1 = lookup(clientID, serverID, db) in
new kS_seed1: fixed_16_keyseed;
let key2 = kgen(kS_seed1) in
event client_begin(clientID, serverID, request);
let msg1 = conc1(request, key2) in
new nonce1: fixed_16_seed;
let cipher1 = E(msg1, key1, nonce1) in
if cond12(cipher1) then 
let msg2 = arithmetic1(clientID, cipher1) in
let msg3 = conc2(clientID, cipher1) in
out(c_out, (msg3, msg2));
in(c_in, (msg4: bitstring, cipher2: bitstring));
if cond13(msg4) then 
if cond14(msg4) then 
let injbot(msg6) = D(cast_bitstring_bounded_1077_ciphertext(cipher2), key2) in
if cond15(msg6, msg4) then 
if cond16(msg6) then 
if cond17(msg6) then 
event client_accept(clientID, serverID, request, cast_bounded_1045_plaintext_fixed_1024_payload(msg6));
yield .

let server = 
in(c_in, ());
if cond19(serverID) then 
if cond20(serverID) then 
new nondet1: nondet;
out(c_out, (port, serverID));
in(c_in, (net_bind_result1: bitstring, var7: bitstring, net_accept_result1: bitstring, msg7: bitstring, msg8: bitstring));
if cond21(net_bind_result1) then 
new nondet2: nondet;
if cond22(net_accept_result1) then 
if cond23(msg7) then 
if cond24(msg7) then 
if cond25(msg8) then 
if cond26(msg8) then 
if cond27(msg7, msg8) then 
if cond28(msg8, xClient) then 
let conc2(client2, cipher3) = msg8 in
if client2 = xClient then 
let key3 = lookup(client2, serverID, db) in
let injbot(msg9) = D(cipher3, key3) in
if cond29(msg9, msg7, msg8) then 
if cond30(msg9) then 
if cond31(msg9) then 
if cond32(msg9) then 
if cond33(msg9) then 
if cond34(msg9) then 
if cond35(msg9) then 
let conc1(var18, key4) = msg9 in
event server_reply(client2, serverID, var18, response);
new nonce2: fixed_16_seed;
let msg12 = E(cast_fixed_1024_payload_bounded_1045_plaintext(response), key4, nonce2) in
if cond38(msg12, response) then 
if cond39(msg12) then 
let msg11 = arithmetic2(msg12) in
out(c_out, (msg12, msg11)); 0 .

(********************************
  <Environment>
*********************************)

let client' =
  in(c_in, xClient: bounded_1024_id);
  
  (*
    For proving correspondences it may be more convincing to let the attacker choose
    the payloads, but we need to generate them randomly to check secrecy.
  *)
  new request: fixed_1024_payload;
  
  out(c_out, ());
  client .

(* The sentinel used in formulating weak secrecy of the response *)
let sentinel =
  in(c_in, response': fixed_1024_payload);
  if response' = response then
  event leaked(xClient, response);
  yield .

let server' = 
  in(c_in, xClient: bounded_1024_id);

  new response: fixed_1024_payload;

  if xClient = clientID then
    out(c_out, ());  
    ( server | sentinel )
  else
    let badHost(xClient') = xClient in
    event bad(xClient);
    out(c_out, ());
    ( server | sentinel ) .

process 
! N(
  (* get a key database and the payloads from the attacker *)
  in(c_in, adb: keydb);
    
  (* generate and insert the honest key *)
  new kAB_seed: fixed_16_keyseed;
  let kAB = kgen(kAB_seed) in
  let db = add_honest(kAB, adb) in

  out(c_out, ());
  ((! N client') | (! N server'))
)

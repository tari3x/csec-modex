
param N.

channel c_in, c_out.

type mstring.

type payload [fixed].

(********************************
  IND-CPA INT-CTXT encryption
*********************************)

type keyseed [fixed, large].
type key [bounded].
type seed [fixed, large].

proba Penc.
proba Pencptxt.
proba Pencctxt.

expand IND_CPA_INT_CTXT_sym_enc(keyseed, key, mstring, mstring, seed, kgen, E, D, injbot, Z, Penc, Pencctxt). 


(*************************** 
  Key lookup
***************************)

type host.
type keydb.

fun add_honest(key, keydb): keydb.

fun lookup(host, host, keydb): key.

const clientID: host.
const serverID: host. 

forall k: key, db: keydb;
  lookup(clientID, serverID, add_honest(k, db)) = k.

(********************************
  Misc
*********************************)

(*
fun key2bs(key): mstring [compos].
fun bs2key(mstring): key.
forall k: key;
  bs2key(key2bs(k)) = k.
*)


(* Concatenation and parsing *)
(*
fun concat1(mstring, mstring): mstring [compos].
fun parse1(mstring): mstring.
fun parse2(mstring): mstring.
*)
(* Z(concat1(...)) *)

(*
fun Zconcat1(mstring, mstring): mstring.

forall x:mstring, y:mstring;
  parse1(concat1(x, y)) = x.

forall x:mstring, y:mstring;
  parse2(concat1(x, y)) = y.
*)
(* Concatenation is length-regular *)
(*
forall x:mstring, y:mstring;
       Z(concat1(x, y)) = Zconcat1(Z(x), Z(y)).
*)

(* All keys have the same length *)
(*
const Zkey: mstring.
forall y:key;
       Z(key2bs(y)) = Zkey.
*)

(********************************
  <Query>
*********************************)

event client_begin(host, host, mstring).
event client_accept(host, host, mstring, mstring).
event server_reply(host, host, mstring, mstring).

query h: host, x: mstring, y:mstring;
  event client_accept(h, serverID, x, y) ==> server_reply(h, serverID, x, y).

query h: host, x: mstring, y:mstring;
  event server_reply(clientID, h, x, y) ==> client_begin(clientID, h, x).

(*
query x: mstring, y:mstring;
  event client_accept(x, y).
*)

(********************************
  <Model>
*********************************)

let A = 0 . let B = 0 .

(********************************
  <Environment>
*********************************)

process 
! N(
  (* get a key database from the attacker *)
  in(c_in, adb: keydb);
    
  (* generate and insert the honest key *)
  new kAB_seed: keyseed;
  let kAB = kgen(kAB_seed) in
  let db = add_honest(kAB, adb) in

  out(c_out, ());
  ((! N A) | (! N B))
)


param N.

channel c_in, c_out.

type mstring [bounded].

(********************************
  IND-CPA INT-CTXT encryption
*********************************)

type keyseed [fixed, large].
type mstring_key [bounded].
type seed [fixed, large].

proba Penc.
proba Pencptxt.
proba Pencctxt.

expand IND_CPA_INT_CTXT_sym_enc(keyseed, mstring_key, mstring, mstring, seed, kgen, E, D, injbot, Z, Penc, Pencctxt). 

fun inverse_injbot(bitstringbot): mstring.


(*************************** 
  Key lookup
***************************)

type mstring_host. 
type keydb.

(* the ids of a designated pair of honest participants *)
const clientID: mstring_host.
const serverID: mstring_host. 

(* key database operations *)
fun add_honest(mstring_key, keydb): keydb.
fun lookup(mstring_host, mstring_host, keydb): mstring_key.

forall k: mstring_key, db: keydb;
  lookup(clientID, serverID, add_honest(k, db)) = k.

(* a host id that carries along the fact that it is compromised *)
fun badHost(mstring_host): mstring_host [compos].

(*
  It is important that in the bad host branch we remove the mention of the honest key,
  so we can show that it isn't leaked anywhere.
*)
forall h:mstring_host, k: mstring_key, db: keydb;
  lookup(badHost(h), serverID, add_honest(k, db)) = lookup(badHost(h), serverID, db).

(********************************
  Misc
*********************************)

type mstring_payload [fixed, large]. 


(*************************** 
 Constants 
***************************)


(*************************** 
  Formatting Functions 
***************************)

(* conc1/2 := tag(70)<1>|lenarg(i0)<4>|arg(i0)<lenarg(i0)>|arg(i1)<lenarg(i1)> *)
fun conc1(mstring, mstring): mstring [compos].



(*************************** 
  Zero Functions 
***************************)

fun Zmstring(mstring): mstring.

(*************************** 
  Length-Regularity 
***************************)

fun Zconc1(mstring, mstring): mstring.
forall var1: mstring, var2: mstring;
  Zmstring(conc1(var1, var2)) = Zconc1(Zmstring(var1), Zmstring(var2)).

(*************************** 
  Typecasting 
***************************)

fun cast_mstring_mstring_key(mstring): mstring_key [compos].
fun cast_mstring_mstring_host(mstring): mstring_host [compos].
fun cast_mstring_key_mstring(mstring_key): mstring [compos].
fun cast_mstring_payload_mstring(mstring_payload): mstring [compos].
fun cast_mstring_host_mstring(mstring_host): mstring [compos].
fun cast_mstring_mstring_payload(mstring): mstring_payload [compos].
forall x: mstring;
  cast_mstring_key_mstring(cast_mstring_mstring_key(x)) = x.
forall x: mstring;
  cast_mstring_host_mstring(cast_mstring_mstring_host(x)) = x.
forall x: mstring_key;
  cast_mstring_mstring_key(cast_mstring_key_mstring(x)) = x.
forall x: mstring_payload;
  cast_mstring_mstring_payload(cast_mstring_payload_mstring(x)) = x.
forall x: mstring_host;
  cast_mstring_mstring_host(cast_mstring_host_mstring(x)) = x.
forall x: mstring;
  cast_mstring_payload_mstring(cast_mstring_mstring_payload(x)) = x.

(************************
  <Crypto2>
*************************)

forall x: mstring;
  Z(x) = Zmstring(x).

(* All honestly generated keys have the same length *)
const Zkey: mstring.
forall x: keyseed;
  Zmstring(cast_mstring_key_mstring(kgen(x))) = Zkey.

(* Rule for zeroing out the payload *)
const Zpayload: mstring.
forall x: mstring_payload;
  Zmstring(cast_mstring_payload_mstring(x)) = Zpayload.

(********************************
  <Query>
*********************************)

event client_begin(mstring_host, mstring_host, mstring_payload).
event client_accept(mstring_host, mstring_host, mstring_payload, mstring_payload).
event server_reply(mstring_host, mstring_host, mstring_payload, mstring_payload).
event bad(mstring_host).

(* Authentication of the server to the client *)
query hClient: mstring_host, hServer: mstring_host, x: mstring_payload, y: mstring_payload;
  event client_accept(hClient, hServer, x, y) ==> server_reply(hClient, hServer, x, y).

(* Authentication of the client to the server *)
query hClient: mstring_host, hServer: mstring_host, x: mstring_payload, y: mstring_payload;
  event server_reply(hClient, hServer, x, y) ==> client_begin(hClient, hServer, x) || bad(hClient).

(* Strong secrecy of the request *)
query secret request.

(* Weak conditional secrecy of the response *)
event leaked(mstring_host, mstring_payload).
query hClient: mstring_host, resp: mstring_payload;
  event leaked(hClient, resp) ==> bad(hClient).


(*************************** 
  Model 
***************************)

let A = 
in(c_in, ());
if clientID = xClient then 
event client_begin(clientID, serverID, request);
new kS_seed1: keyseed;
let kS1 = kgen(kS_seed1) in
new nonce1: seed;
let msg1 = conc1(cast_mstring_host_mstring(clientID), E(conc1(cast_mstring_payload_mstring(request), cast_mstring_key_mstring(kS1)), lookup(clientID, serverID, db), nonce1)) in
out(c_out, (msg1));
in(c_in, (msg2: mstring, msg3: mstring));
let injbot(var1) = D(msg3, kS1) in
event client_accept(clientID, serverID, request, cast_mstring_mstring_payload(var1));
yield.

let B = 
in(c_in, (msg1: mstring, msg2: mstring));
let conc1(var1, var2) = msg2 in
let var6 = cast_mstring_host_mstring(xClient) in
if var1 = var6 then 
let injbot(var3) = D(var2, lookup(cast_mstring_mstring_host(var1), serverID, db)) in
let conc1(var4, var5) = var3 in
event server_reply(cast_mstring_mstring_host(var1), serverID, cast_mstring_mstring_payload(var4), response);
new nonce1: seed;
let cipher1 = E(cast_mstring_payload_mstring(response), cast_mstring_mstring_key(var5), nonce1) in
out(c_out, (cipher1)); 0 .

(********************************
  <Environment>
*********************************)

let A' =
  in(c_in, xClient: mstring_host);
  
  (*
    For proving correspondences it may be more convincing to let the attacker choose
    the payloads, but we need to generate them randomly to check secrecy.
  *)
  new request: mstring_payload;
  
  out(c_out, ());
  A .

(* The sentinel used in formulating weak secrecy of the response *)
let sentinel =
  in(c_in, response': mstring_payload);
  if response' = response then
  event leaked(xClient, response);
  yield .

let B' = 
  in(c_in, xClient: mstring_host);

  new response: mstring_payload;

  if xClient = clientID then
    out(c_out, ());  
    ( B | sentinel )
  else
    let badHost(xClient') = xClient in
    event bad(xClient);
    out(c_out, ());
    ( B | sentinel ) .


process 
! N(
  (* get a key database and the payloads from the attacker *)
  in(c_in, adb: keydb);
    
  (* generate and insert the honest key *)
  new kAB_seed: keyseed;
  let kAB = kgen(kAB_seed) in
  let db = add_honest(kAB, adb) in

  out(c_out, ());
  ((! N A') | (! N B'))
)
